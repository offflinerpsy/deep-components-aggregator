src/live/search.mjs:4:import { fetchHtmlCached } from '../scrape/cache.mjs';
src/live/handler.mjs:6:  'Cache-Control': 'no-cache',
src/live/http.mjs:13:  res.setHeader('Cache-Control', 'no-cache');
src/live/ingest.mjs:6:import { fetchHtmlCached } from '../scrape/cache.mjs';
src/currency.js:61:  let cached = null;
src/currency.js:65:      cached = JSON.parse(txt);
src/currency.js:67:      if (cached && cached.ts && (now() - cached.ts) < TTL_MS) {
src/currency.js:70:          USD: cached.USD || 0, 
src/currency.js:71:          EUR: cached.EUR || 0, 
src/currency.js:72:          ts: cached.ts, 
src/currency.js:73:          cached: true 
src/currency.js:83:      if (cached && cached.USD > 0 && cached.EUR > 0) {
src/currency.js:84:        console.warn('[currency] CBR fetch failed, using Last-Known-Good (stale cache)');
src/currency.js:87:          USD: cached.USD,
src/currency.js:88:          EUR: cached.EUR,
src/currency.js:89:          ts: cached.ts,
src/currency.js:90:          cached: true,
src/currency.js:110:      cached: false 
src/api/search.mjs:6:import { readCachedSearch, cacheSearch } from '../db/sql.mjs';
src/api/search.mjs:29:      const cached = readCachedSearch(db, q.toLowerCase(), TTL_SEARCH_MS);
src/api/search.mjs:30:      if(cached){
src/api/search.mjs:31:        logTrace(`search q="${q}" source=${cached.meta.source} cached=1 rows=${cached.rows.length}`);
src/api/search.mjs:32:        res.json({ok:true,q,rows:cached.rows,meta:cached.meta});
src/api/search.mjs:47:          cacheSearch(db, q.toLowerCase(), rows, {source:'farnell'});
src/api/search.mjs:48:          logTrace(`search q="${q}" source=farnell cached=0 rows=${rows.length}`);
src/api/search.mjs:51:          logTrace(`search q="${q}" source=farnell cached=0 rows=0 error=1`);
src/api/search.mjs:59:                cacheSearch(db, q.toLowerCase(), rows, {source:'mouser'});
src/api/search.mjs:66:                  cacheSearch(db, q.toLowerCase(), rows2, {source:'farnell'});
src/api/search.mjs:76:                cacheSearch(db, q.toLowerCase(), rows, {source:'mouser'});
src/api/search.mjs:83:                  cacheSearch(db, q.toLowerCase(), rows2, {source:'farnell'});
src/api/product.mjs:4:import { readCachedProduct, cacheProduct } from '../db/sql.mjs';
src/api/product.mjs:89:    const cached = readCachedProduct(db, src, id, TTL_PRODUCT_MS);
src/api/product.mjs:90:    if(cached){
src/api/product.mjs:91:      logTrace(`product src=${src} id="${id}" cached=1 photo=${cached.photo ? 'yes' : 'no'}`);
src/api/product.mjs:92:      res.json({ok:true, product: cached, meta:{cached:true}});
src/api/product.mjs:102:          cacheProduct(db, 'mouser', id, p);
src/api/product.mjs:103:          logTrace(`product src=${src} id="${id}" cached=0 photo=${p.photo ? 'yes' : 'no'}`);
src/api/product.mjs:107:          logTrace(`product src=${src} id="${id}" cached=0 error=1`);
src/api/product.mjs:116:          cacheProduct(db, 'farnell', id, p);
src/api/product.mjs:117:          logTrace(`product src=${src} id="${id}" cached=0 photo=${p.photo ? 'yes' : 'no'}`);
src/api/product.mjs:121:          logTrace(`product src=${src} id="${id}" cached=0 error=1`);
src/api/http.mjs:25:  const root = 'data/cache/html';
src/api/http.mjs:43:  const counters = { indexCount: lastIndexCount, cacheEntries: countCacheEntries(), pendingTasks: pendingTasks.size };
src/api/http.mjs:179:  res.setHeader('Cache-Control', 'no-cache');
src/api/routes/product.js:4:// import { cacheService } from '../../../backend/src/services/cache.js'; // Отключено - используем простое кеширование
src/api/routes/product.js:28:    const cacheKey = `product:${mpn}`;
src/api/routes/product.js:29:    // const cachedData = cacheService.get(cacheKey); // Отключено
src/api/routes/product.js:31:    // if (cachedData) {
src/api/routes/product.js:32:    //   console.log(`⚡ Cache hit for ${mpn}, returning cached data`);
src/api/routes/product.js:35:    //     product: cachedData.product,
src/api/routes/product.js:37:    //       ...cachedData.meta,
src/api/routes/product.js:38:    //       mode: 'cached',
src/api/routes/product.js:91:    // cacheService.set(cacheKey, responseData, 3600); // Отключено
src/api/live-search.mjs:13:    res.setHeader('Cache-Control', 'no-cache');
src/scrapers/mouser.mjs:29:        'Cache-Control': 'no-cache'
src/currency/currencyConverter.js:8:        this.cacheExpiry = 6 * 60 * 60 * 1000; // 6 hours in milliseconds
src/currency/currencyConverter.js:19:    // Initialize converter and load cached rates
src/currency/currencyConverter.js:27:        const cached = this.loadCachedRates();
src/currency/currencyConverter.js:28:        if (cached && this.isCacheValid()) {
src/currency/currencyConverter.js:29:            console.info('Currency converter: using cached rates');
src/currency/currencyConverter.js:234:        return (Date.now() - this.lastUpdate.getTime()) < this.cacheExpiry;
src/currency/currencyConverter.js:240:        const cacheData = {
src/currency/currencyConverter.js:246:        localStorage.setItem('currencyRates', JSON.stringify(cacheData));
src/currency/currencyConverter.js:252:        const cached = localStorage.getItem('currencyRates');
src/currency/currencyConverter.js:253:        if (!cached) return false;
src/currency/currencyConverter.js:255:        const cacheData = JSON.parse(cached);
src/currency/currencyConverter.js:256:        if (!cacheData || !Array.isArray(cacheData.rates)) return false;
src/currency/currencyConverter.js:259:        cacheData.rates.forEach(([currency, rate]) => {
src/currency/currencyConverter.js:263:        this.lastUpdate = new Date(cacheData.lastUpdate);
src/currency/currencyConverter.js:280:            cacheValid: this.isCacheValid(),
src/currency/cbr-rates.js:8:let cacheTimestamp = 0;
src/currency/cbr-rates.js:23:  if (ratesCache && (now - cacheTimestamp) < CACHE_TTL) {
src/currency/cbr-rates.js:24:    debugLog('Using cached rates', { age: Math.round((now - cacheTimestamp) / 1000 / 60) + ' minutes' });
src/currency/cbr-rates.js:46:      debugLog('Returning stale cache due to fetch error');
src/currency/cbr-rates.js:116:  cacheTimestamp = now;
src/currency/cbr-rates.js:201:  cacheTimestamp = 0;
src/currency/cbr-rates.js:202:  debugLog('Rates cache cleared');
src/currency/searchIntegration.js:178:            cacheValid: status.cacheValid,
src/qa/runner.js:140:      currency_rates_cached: apiResponse.rates_cached || false,
src/integrations/digikey/client.mjs:26:let cachedToken = null;
src/integrations/digikey/client.mjs:45:  // Return cached token if still valid
src/integrations/digikey/client.mjs:46:  if (cachedToken && Date.now() < tokenExpiry) {
src/integrations/digikey/client.mjs:47:    return cachedToken;
src/integrations/digikey/client.mjs:73:  cachedToken = data.access_token;
src/integrations/digikey/client.mjs:78:  return cachedToken;
src/i18n/translation-cache.mjs:4: * In-memory cache for RU→EN translations
src/i18n/translation-cache.mjs:23:    this.cache = new Map();
src/i18n/translation-cache.mjs:33:   * Normalize cache key
src/i18n/translation-cache.mjs:51:   * Get translation from cache
src/i18n/translation-cache.mjs:57:    const entry = this.cache.get(key);
src/i18n/translation-cache.mjs:65:      this.cache.delete(key);
src/i18n/translation-cache.mjs:72:    this.cache.delete(key);
src/i18n/translation-cache.mjs:73:    this.cache.set(key, entry);
src/i18n/translation-cache.mjs:80:      cached: true,
src/i18n/translation-cache.mjs:81:      cacheAge: Date.now() - entry.timestamp
src/i18n/translation-cache.mjs:86:   * Store translation in cache
src/i18n/translation-cache.mjs:94:    if (this.cache.size >= this.maxSize) {
src/i18n/translation-cache.mjs:95:      const firstKey = this.cache.keys().next().value;
src/i18n/translation-cache.mjs:96:      this.cache.delete(firstKey);
src/i18n/translation-cache.mjs:100:    this.cache.set(key, {
src/i18n/translation-cache.mjs:109:   * Check if query exists in cache (without updating LRU)
src/i18n/translation-cache.mjs:111:   * @returns {boolean} True if cached and not expired
src/i18n/translation-cache.mjs:115:    const entry = this.cache.get(key);
src/i18n/translation-cache.mjs:122:      this.cache.delete(key);
src/i18n/translation-cache.mjs:131:   * Clear entire cache
src/i18n/translation-cache.mjs:134:    this.cache.clear();
src/i18n/translation-cache.mjs:144:   * Get cache statistics
src/i18n/translation-cache.mjs:152:      size: this.cache.size,
src/i18n/translation-cache.mjs:164:   * Get all cache entries (for debugging)
src/i18n/translation-cache.mjs:165:   * @returns {Array} Array of cache entries
src/i18n/translation-cache.mjs:168:    return Array.from(this.cache.entries()).map(([key, value]) => ({
src/i18n/ru-en-translator.mjs:20:import translationCache from './translation-cache.mjs';
src/i18n/ru-en-translator.mjs:256:  const cached = translationCache.get(query);
src/i18n/ru-en-translator.mjs:257:  if (cached) {
src/i18n/ru-en-translator.mjs:260:      translated: cached.translated,
src/i18n/ru-en-translator.mjs:263:      cacheAge: cached.cacheAge,
src/i18n/ru-en-translator.mjs:265:        glossaryCoverage: cached.coverage,
src/i18n/ru-en-translator.mjs:266:        missingWords: cached.missingWords
src/i18n/ru-en-translator.mjs:268:      provider: 'cache',
src/i18n/ru-en-translator.mjs:345:    cache: translationCache.getStats(),
src/scrape/cache.mjs:18:const CACHE_DIR = 'data/cache/html';
src/scrape/cache.mjs:19:const META_DIR = 'data/cache/meta';
src/scrape/cache.mjs:89:  const cachePath = getCachePath(key);
src/scrape/cache.mjs:94:    if (fs.existsSync(cachePath) && fs.existsSync(metaPath)) {
src/scrape/cache.mjs:102:      const html = fs.readFileSync(cachePath, 'utf8');
src/scrape/cache.mjs:112:    console.error(`Error reading from cache for ${url}:`, error);
src/scrape/cache.mjs:132:  const cachePath = getCachePath(key);
src/scrape/cache.mjs:137:    fs.writeFileSync(cachePath, html);
src/scrape/cache.mjs:150:    console.error(`Error saving to cache for ${url}:`, error);
src/scrape/cache.mjs:163:  console.log(`[CACHE] Fetching ${url} with cache`);
src/scrape/cache.mjs:167:    diagnostics.addEvent('cache_request_start', `Starting cached fetch for ${url}`, {
src/scrape/cache.mjs:175:  const cacheResult = getFromCache(url);
src/scrape/cache.mjs:178:  if (cacheResult.exists && !cacheResult.stale) {
src/scrape/cache.mjs:182:      diagnostics.addEvent('cache_hit', `Returning fresh cache for ${url}`, {
src/scrape/cache.mjs:183:        cacheAge: Date.now() - cacheResult.meta.timestamp
src/scrape/cache.mjs:189:      html: cacheResult.html,
src/scrape/cache.mjs:190:      status: cacheResult.meta.status,
src/scrape/cache.mjs:191:      cached: true,
src/scrape/cache.mjs:193:      provider: cacheResult.meta.provider,
src/scrape/cache.mjs:194:      usedKey: 'cache'
src/scrape/cache.mjs:261:            cached: false,
src/scrape/cache.mjs:311:  if (cacheResult.exists) {
src/scrape/cache.mjs:312:    console.log(`[CACHE] All providers failed, using stale cache for ${url}`);
src/scrape/cache.mjs:315:      diagnostics.addEvent('cache_stale_if_error', `Returning stale cache for ${url} due to provider errors`, {
src/scrape/cache.mjs:316:        cacheAge: Date.now() - cacheResult.meta.timestamp
src/scrape/cache.mjs:322:      html: cacheResult.html,
src/scrape/cache.mjs:323:      status: cacheResult.meta.status,
src/scrape/cache.mjs:324:      cached: true,
src/scrape/cache.mjs:327:      provider: cacheResult.meta.provider,
src/scrape/cache.mjs:328:      usedKey: 'stale_cache'
src/scrape/cache.mjs:333:  console.error(`[CACHE] All providers failed for ${url} and no cache available`);
src/scrape/cache.mjs:344:    error: 'All providers failed and no cache available',
src/scrape/cache.mjs:345:    cached: false,
src/scrape/live-search.mjs:1:import { fetchHtmlCached } from './cache.mjs';
src/scrape/rotator.mjs:443:  const cacheKey = query.toLowerCase().trim();
src/scrape/rotator.mjs:446:  if (state.queryCache[cacheKey] && now - state.queryCache[cacheKey] < ttl) {
src/scrape/rotator.mjs:451:  state.queryCache[cacheKey] = now;
src/services/rates-cbr.js:4:let cacheTimestamp = null;
src/services/rates-cbr.js:8:  if (!ratesCache || !cacheTimestamp || Date.now() - cacheTimestamp > CACHE_TTL) {
src/services/rates-cbr.js:29:      cacheTimestamp = Date.now();
src/services/rates-cbr.js:37:    cacheTimestamp = Date.now();
src/services/rates-cbr.js:55:    cacheTimestamp = Date.now();
src/db/sql.mjs:27:    CREATE TABLE IF NOT EXISTS product_cache(
src/db/sql.mjs:39:export function cacheSearch(db, q, rows, meta){
src/db/sql.mjs:58:  return { rows, meta: { source: s.source, total: rows.length, cached: true } };
src/db/sql.mjs:61:export function cacheProduct(db, src, id, product){
src/db/sql.mjs:63:  db.prepare('INSERT OR REPLACE INTO product_cache (src,id,ts,product) VALUES (?,?,?,?)')
src/db/sql.mjs:68:  const r = db.prepare('SELECT ts,product FROM product_cache WHERE src=? AND id=?').get(src,id);
