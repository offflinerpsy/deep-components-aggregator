## core orchestrator

## currency convert

## live search entry
src/api/http.mjs:175:// /api/live/search - полноценный LIVE-поток с SSE
src/api/http.mjs:176:router.get('/live/search', (req, res) => {
src/api/live-search.mjs:11:  app.get('/api/live/search', (req, res) => {
server.js:399:app.get('/api/live/search', async (req, res) => {

## providers list

### orchestrator file

### currency.convert excerpt

### provider registry
// config/providers.mjs
export const PROVIDER_CONFIG = {
  SCRAPERAPI_KEY: "a91efbc32580c3e8ab8b06ce9b6dc509",
  SCRAPINGBEE_KEYS: [
    "ZINO11YL3C43ZKPK6DZM9KUNASN5HSYWNAM3EXYV8FR2OKSUCCOW1NS0BF8PCEFY2H7WZGNBOURSYSLZ",
    "1KYSOE...e4346"
  ],
  PROVIDER_TIMEOUT_MS: 10000,
  HTTP_PROXY: "",
  HTTPS_PROXY: ""
};

### live orchestrator excerpt
import {get as bee} from '../scrape/providers/scrapingbee.mjs';
import {get as sapi} from '../scrape/providers/scraperapi.mjs';
import {get as bot} from '../scrape/providers/scrapingbot.mjs';
import {extractProductLinks} from '../parsers/chipdip/listing.mjs';
import {toCanon} from '../parsers/chipdip/product.mjs';
import {insertProduct, upsertOffer} from '../db/sqlite.mjs';
import pLimit from '../core/p-limit-mock.mjs';
import {fetch} from 'undici';

const lim = pLimit(4); // общая конкуренция (берём мягко)

const providers = [bee, sapi, bot];

const hit = async (url) => {
  const fn = providers[Math.floor(Math.random()*providers.length)];
  const r = await fn(url);
  if (r.status !== 'ok') return {ok:false};
  return {ok:true, html:r.html, provider:r.provider};
};

export const plan = async (q, emit, deadlineMs=12000) => {
  const start = Date.now();
  const qTrim = (q||'').trim();
  if (!qTrim) return;

  // 1) если похоже на MPN/артикул — сразу бьём в карточку по поиску чипдипа
  const searchUrl = `https://www.chipdip.ru/search?searchtext=${encodeURIComponent(qTrim)}`;
  const r0 = await hit(searchUrl);
  if (r0.ok) {
    const links = extractProductLinks(r0.html);
    for (const url of links) {
      if (Date.now()-start > deadlineMs) return;
      await lim(async ()=>{
        const r1 = await hit(url);
        if (!r1.ok) return;
        const canon = toCanon(r1.html, url);
        const pid = insertProduct(canon);
        canon.offers?.forEach(o => upsertOffer(pid, {...o, provider:r1.provider}));
        emit({type:'item', item:{...canon, id: pid}});
      })();
    }
  }

  // 2) если ничего не пришло — мягкая добивка (страница каталога/вариации)
  if (Date.now()-start < deadlineMs && (!r0.ok)) {
    const alt = `https://www.chipdip.ru/search?searchtext=${encodeURIComponent(qTrim)}&page=2`;
    const rA = await hit(alt);
    if (rA.ok) {
      extractProductLinks(rA.html).slice(0,10).forEach(async url=>{
        if (Date.now()-start > deadlineMs) return;
        await lim(async ()=>{
          const rB = await hit(url);
          if (!rB.ok) return;
          const canon = toCanon(rB.html, url);
          const pid = insertProduct(canon);
          canon.offers?.forEach(o => upsertOffer(pid, {...o, provider:rB.provider}));
          emit({type:'item', item:{...canon, id: pid}});
        })();
      });
    }
  }
};

### services orchestrator excerpt
import { parseChipDip } from '../adapters/ru/chipdip.js';
import { parsePromelec } from '../adapters/ru/promelec.js';
import { parsePlatan } from '../adapters/ru/platan.js';
import { parseElectronshik } from '../adapters/ru/electronshik.js';
import { parseElitan } from '../adapters/ru/elitan.js';
import { searchOEMsTrade } from '../../adapters/oemstrade.js';
import { convertToRub } from '../services/rates-cbr.js';
import Ajv from 'ajv';

const ajv = new Ajv();

// Схема для валидации RU-канона
const ruCanonSchema = {
  type: 'object',
  properties: {
    ok: { type: 'boolean' },
    source: { type: 'string' },
    mpn: { type: 'string' },
    mpn_clean: { type: 'string' },
    title: { type: 'string' },
    description: { type: 'string' },
    images: { type: 'array', items: { type: 'string' } },
    datasheets: { type: 'array', items: { type: 'string' } },
    package: { type: 'string' },
    packaging: { type: 'string' },
    technical_specs: { type: 'object' },
    url: { type: 'string' }
  },
  required: ['ok', 'source', 'mpn']
};

const validateRuCanon = ajv.compile(ruCanonSchema);

// Функция для оценки полноты данных
function calculateCompleteness(data) {
  if (!data.ok) return 0;
  
  let score = 0;
  const fields = ['title', 'description', 'images', 'datasheets', 'technical_specs'];
  
  fields.forEach(field => {
    if (field === 'images' || field === 'datasheets') {
      if (data[field] && data[field].length > 0) score += 1;
    } else if (field === 'technical_specs') {
      if (data[field] && Object.keys(data[field]).length > 0) score += 1;
    } else {
      if (data[field] && data[field].trim()) score += 1;
    }
  });
  
  return score;
}

export async function orchestrateProduct(mpn) {
  const startTime = Date.now();
  
  // Запуск всех RU-адаптеров параллельно
  const ruAdapters = [
    parseChipDip(mpn),
    parsePromelec(mpn),
    parsePlatan(mpn),
    parseElectronshik(mpn),
    parseElitan(mpn)
  ];
  
  const ruResults = await Promise.allSettled(ruAdapters);
  
  // Выбор наиболее полного RU-контента
  let bestRuContent = null;
  let maxCompleteness = 0;
  
  ruResults.forEach((result, index) => {
    if (result.status === 'fulfilled' && result.value.ok) {
      const completeness = calculateCompleteness(result.value);
      if (completeness > maxCompleteness) {
        maxCompleteness = completeness;
        bestRuContent = result.value;
      }
    }
  });
  
  // Если нет RU-контента, используем только коммерческие данные
  if (!bestRuContent) {
    console.log(JSON.stringify({
      route: 'orchestrator',
      mpn: mpn,
      fallback: 'no-ru-content',
      using_oemstrade_only: true
    }));
    
    // Получение коммерческих данных от OEMsTrade
    const commercialResults = await searchOEMsTrade(mpn);
    
    if (!Array.isArray(commercialResults) || commercialResults.length === 0) {
      // Создаем fallback данные когда нет результатов
      return {
        ok: true,
        source: 'fallback',
        mpn: mpn,
        mpn_clean: mpn.replace(/\/[A-Z0-9-]+$/, '').replace(/-[A-Z]$/, ''),
        title: mpn,
        description: 'Компонент не найден в базе данных',
        images: [],
        datasheets: [],
        package: '',
        packaging: '',
        technical_specs: {},
        suppliers: [],
        regions: [],
        stock_total: 0,
        price_min: 0,
        price_min_currency: 'RUB',
        price_min_rub: 0,
        url: ''
      };
    }
    
    // Найти точное совпадение MPN или взять первый результат
    const commercialData = commercialResults.find(item => item.mpn === mpn) || commercialResults[0];
    

### currency converter excerpt
// src/currency.js — курсы ЦБ РФ (TTL 12ч), без try/catch
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);
const DATA_DIR   = path.join(__dirname, "..", "data");
const RATES_FP   = path.join(DATA_DIR, "rates.json");
const TTL_MS     = 12 * 60 * 60 * 1000; // 12 часов

function ensureDir(dir){ 
  if(!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); 
}

function now(){ 
  return Date.now(); 
}

function parseCbrXml(xml){
  if (!xml || xml.length < 1000) return { ok: false };
  
  const getRate = code => {
    const re = new RegExp(`<CharCode>${code}</CharCode>[\\s\\S]*?<Value>([\\d,]+)</Value>`, "i");
    const match = re.exec(xml);
    if (!match) return 0;
    const num = Number(match[1].replace(",", "."));
    return Number.isFinite(num) ? num : 0;
  };
  
  const USD = getRate("USD");
  const EUR = getRate("EUR");
  
  if (USD <= 0 && EUR <= 0) return { ok: false };
  
  return { 
    ok: true, 
    ts: now(), 
    USD, 
    EUR 
  };
}

function fetchCbr(){
  const url = "https://www.cbr.ru/scripts/XML_daily.asp";
  return fetch(url, { 
    headers: { 
      "Accept": "application/xml",
      "User-Agent": "Mozilla/5.0 (compatible; DEEP-aggregator/1.0)"
    } 
  })
  .then(r => r.ok ? r.text().then(t => ({ ok: true, text: t })) : ({ ok: false }))
  .then(x => x.ok ? parseCbrXml(x.text) : ({ ok: false }))
  .catch(() => ({ ok: false }));
}

export function getRates(){
  ensureDir(DATA_DIR);
  
  // Проверяем кеш
  if (fs.existsSync(RATES_FP)) {
    const txt = fs.readFileSync(RATES_FP, "utf-8");
    if (txt && txt.trim().length > 2) {
      const cached = JSON.parse(txt);
      if (cached && cached.ts && (now() - cached.ts) < TTL_MS) {
        return Promise.resolve({ 
          ok: true, 
          USD: cached.USD || 0, 
          EUR: cached.EUR || 0, 
          ts: cached.ts, 
          cached: true 
        });
      }
    }
  }
  
  // Получаем свежие данные
  return fetchCbr().then(result => {
    if (!result.ok) return { ok: false };
    
    const rates = { 
      ts: result.ts, 
      USD: result.USD, 
      EUR: result.EUR 
    };
    
    fs.writeFileSync(RATES_FP, JSON.stringify(rates, null, 2));
    
    return { 
      ok: true, 
      USD: result.USD, 
      EUR: result.EUR, 
      ts: result.ts, 
      cached: false 
    };
  });
}

// Конвертация валюты в рубли
export async function convertToRub(currency) {
  if (currency === 'RUB') return 1;
  
  const rates = await getRates();
  if (!rates.ok) return null;
  
  switch (currency) {
    case 'USD': return rates.USD;
    case 'EUR': return rates.EUR;
    default: return null;
  }
}
### provider registry
// config/providers.mjs
export const PROVIDER_CONFIG = {
  SCRAPERAPI_KEY: "a91efbc32580c3e8ab8b06ce9b6dc509",
  SCRAPINGBEE_KEYS: [
    "ZINO11YL3C43ZKPK6DZM9KUNASN5HSYWNAM3EXYV8FR2OKSUCCOW1NS0BF8PCEFY2H7WZGNBOURSYSLZ",
    "1KYSOE...e4346"
  ],
  PROVIDER_TIMEOUT_MS: 10000,
  HTTP_PROXY: "",
  HTTPS_PROXY: ""
};
