/**
 * Sequelize models for AdminJS
 * All tables for admin panel
 */

import { DataTypes } from 'sequelize'
import sequelize from './sequelize.js'
import bcrypt from 'bcrypt'

// ============================================
// Admin Users (авторизация в админке)
// ============================================
const AdminUser = sequelize.define('AdminUser', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  password_hash: {
    type: DataTypes.STRING,
    allowNull: false
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  role: {
    type: DataTypes.ENUM('admin', 'moderator'),
    defaultValue: 'admin'
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: 'admin_users',
  indexes: [
    { fields: ['email'], unique: true }
  ]
})

// Hash password before save
AdminUser.beforeCreate(async (user) => {
  if (user.password_hash) {
    user.password_hash = await bcrypt.hash(user.password_hash, 10)
  }
})

AdminUser.beforeUpdate(async (user) => {
  if (user.changed('password_hash')) {
    user.password_hash = await bcrypt.hash(user.password_hash, 10)
  }
})

// Verify password method
AdminUser.prototype.verifyPassword = async function(password) {
  return bcrypt.compare(password, this.password_hash)
}

// ============================================
// Orders (заказы клиентов) — Синхронизировано с таблицей orders
// ============================================
const Order = sequelize.define('Order', {
  id: {
    type: DataTypes.TEXT,
    primaryKey: true,
    comment: 'UUID v4 string generated by API'
  },
  order_code: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: 'Short human-friendly code like ORD-XXXXXX'
  },
  customer_name: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  customer_contact: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Email or phone in E.164 format'
  },
  customer_email: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: 'Extracted from customer_contact JSON for convenience'
  },
  mpn: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Manufacturer Part Number'
  },
  manufacturer: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  qty: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  pricing_snapshot: {
    type: DataTypes.TEXT,
    allowNull: false,
    get() {
      const raw = this.getDataValue('pricing_snapshot');
      return raw ? JSON.parse(raw) : null;
    },
    set(value) {
      this.setDataValue('pricing_snapshot', JSON.stringify(value));
    },
    comment: 'JSON string: {base_price_rub, markup_percent, final_price_rub}'
  },
  dealer_links: {
    type: DataTypes.TEXT,
    get() {
      const raw = this.getDataValue('dealer_links');
      return raw ? JSON.parse(raw) : null;
    },
    set(value) {
      this.setDataValue('dealer_links', JSON.stringify(value));
    },
    comment: 'JSON string: array of {dealer, url}'
  },
  status: {
    type: DataTypes.TEXT,
    defaultValue: 'pending'
  },
  status_comment: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  status_history: {
    type: DataTypes.TEXT,
    allowNull: true,
    get() {
      const raw = this.getDataValue('status_history');
      return raw ? JSON.parse(raw) : null;
    },
    set(value) {
      this.setDataValue('status_history', JSON.stringify(value));
    },
    comment: 'JSON array of {ts,status,comment,admin_id|admin_email}'
  },
  meta: {
    type: DataTypes.TEXT,
    get() {
      const raw = this.getDataValue('meta');
      return raw ? JSON.parse(raw) : null;
    },
    set(value) {
      this.setDataValue('meta', JSON.stringify(value));
    },
    comment: 'JSON string: {comment, ...}'
  },
  user_id: {
    type: DataTypes.TEXT,
    comment: 'Optional user ID if authenticated'
  }
}, {
  tableName: 'orders',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['order_code'] },
    { fields: ['customer_contact'] },
    { fields: ['customer_email'] },
    { fields: ['mpn'] },
    { fields: ['status'] },
    { fields: ['created_at'] }
  ]
})

// ============================================
// API Health (мониторинг API)
// ============================================
const ApiHealth = sequelize.define('ApiHealth', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  service: {
    type: DataTypes.ENUM('digikey', 'mouser', 'farnell', 'tme'),
    allowNull: false,
    unique: true
  },
  status: {
    type: DataTypes.ENUM('online', 'offline', 'degraded'),
    defaultValue: 'offline'
  },
  last_check: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  },
  response_time_ms: {
    type: DataTypes.INTEGER,
    comment: 'Last response time in milliseconds'
  },
  error_message: {
    type: DataTypes.TEXT
  },
  success_rate_24h: {
    type: DataTypes.DECIMAL(5, 2),
    comment: 'Success rate in last 24 hours (%)'
  }
}, {
  tableName: 'api_health',
  indexes: [
    { fields: ['service'], unique: true }
  ]
})

// ============================================
// API Keys (управление ключами)
// ============================================
const ApiKey = sequelize.define('ApiKey', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  service: {
    type: DataTypes.ENUM('digikey', 'mouser', 'farnell', 'tme', 'oemstrade'),
    allowNull: false
  },
  key_name: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'e.g., "CLIENT_ID", "API_KEY"'
  },
  key_value: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Encrypted value'
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  expires_at: {
    type: DataTypes.DATE,
    comment: 'Key expiration date (if applicable)'
  },
  last_used: {
    type: DataTypes.DATE
  }
}, {
  tableName: 'api_keys',
  indexes: [
    { fields: ['service', 'key_name'] }
  ]
})

// ============================================
// Static Pages (статические страницы)
// ============================================
function slugify(input) {
  const s = String(input || '')
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9а-яё\-\s_]/g, '') // убрать лишние символы (оставить буквы/цифры/дефис/пробел/нижнее подчёркивание)
    .replace(/[\s_]+/g, '-')             // пробелы/подчёркивания -> дефис
    .replace(/-+/g, '-')                  // схлопнуть повторяющиеся дефисы
    .replace(/^-|-$|\.+$/g, '')          // обрезать дефисы по краям и точки в конце
  return s
}

const StaticPage = sequelize.define('StaticPage', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  slug: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    comment: 'URL slug (e.g., "about-us", "contacts")'
  },
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  content: {
    type: DataTypes.TEXT,
    comment: 'HTML or Markdown content'
  },
  meta_description: {
    type: DataTypes.TEXT
  },
  is_published: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  },
  position: {
    type: DataTypes.ENUM('header', 'footer', 'both'),
    defaultValue: 'footer',
    comment: 'Where to show link'
  },
  section: {
    type: DataTypes.ENUM('about', 'help', 'info'),
    defaultValue: 'info',
    comment: 'Footer section grouping'
  },
  sort_order: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  }
}, {
  tableName: 'static_pages',
  indexes: [
    { fields: ['slug'], unique: true },
    { fields: ['is_published'] },
    { fields: ['position'] },
    { fields: ['section'] }
  ]
})

// Автогенерация slug на основе title, если не задан
StaticPage.beforeValidate((page) => {
  if (!page.slug && page.title) {
    page.slug = slugify(page.title)
  }
})

// Нормализация slug перед сохранением
StaticPage.beforeSave((page) => {
  if (page.slug) {
    page.slug = slugify(page.slug)
  }
})

// ============================================
// Manual Products (ручные товары)
// ============================================
const ManualProduct = sequelize.define('ManualProduct', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  mpn: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    comment: 'Manufacturer Part Number'
  },
  manufacturer: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT
  },
  price: {
    type: DataTypes.DECIMAL(10, 2)
  },
  currency: {
    type: DataTypes.STRING(3),
    defaultValue: 'RUB'
  },
  region: {
    type: DataTypes.STRING,
    comment: 'e.g., "RU", "US", "EU"'
  },
  stock: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  image_url: {
    type: DataTypes.STRING
  },
  datasheet_url: {
    type: DataTypes.STRING
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  category: {
    type: DataTypes.STRING,
    comment: 'Product category (optional)'
  },
  technical_specs: {
    type: DataTypes.TEXT,
    comment: 'JSON string with technical specifications'
  },
  images: {
    type: DataTypes.TEXT,
    comment: 'JSON array of image URLs'
  },
  datasheets: {
    type: DataTypes.TEXT,
    comment: 'JSON array of datasheet URLs'
  },
  pricing: {
    type: DataTypes.TEXT,
    comment: 'JSON array of pricing breaks'
  },
  availability: {
    type: DataTypes.TEXT,
    comment: 'JSON object with availability info'
  },
  regions: {
    type: DataTypes.TEXT,
    comment: 'JSON array of regions'
  },
  package: {
    type: DataTypes.STRING,
    comment: 'Package type'
  },
  packaging: {
    type: DataTypes.STRING,
    comment: 'Packaging type'
  },
  vendor_url: {
    type: DataTypes.STRING,
    comment: 'Vendor product page URL'
  },
  source: {
    type: DataTypes.STRING,
    comment: 'Source/provider name'
  }
}, {
  tableName: 'manual_products',
  indexes: [
    { fields: ['mpn'], unique: true },
    { fields: ['manufacturer'] },
    { fields: ['is_active'] }
  ]
})

// ============================================
// Project Stats (статистика проекта)
// ============================================
const ProjectStat = sequelize.define('ProjectStat', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
    unique: true
  },
  total_searches: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  cache_hits: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  live_searches: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  total_orders: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  avg_response_time_ms: {
    type: DataTypes.INTEGER
  }
}, {
  tableName: 'project_stats',
  indexes: [
    { fields: ['date'], unique: true }
  ]
})

// ============================================
// Admin Notifications
// ============================================
const AdminNotification = sequelize.define('AdminNotification', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  type: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Notification type (e.g., "order", "system", "alert")'
  },
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  message: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  payload: {
    type: DataTypes.TEXT,
    get() {
      const raw = this.getDataValue('payload');
      return raw ? JSON.parse(raw) : null;
    },
    set(value) {
      this.setDataValue('payload', JSON.stringify(value));
    },
    comment: 'Additional JSON data related to the notification'
  },
  read_at: {
    type: DataTypes.DATE,
    allowNull: true
  },
  priority: {
    type: DataTypes.ENUM('low', 'normal', 'high'),
    defaultValue: 'normal'
  }
}, {
  tableName: 'admin_notifications',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['type'] },
    { fields: ['read_at'] },
    { fields: ['priority'] },
    { fields: ['created_at'] }
  ]
})

// ============================================
// Settings (system configuration)
// ============================================
const Setting = sequelize.define('Setting', {
  key: {
    type: DataTypes.STRING,
    primaryKey: true,
    allowNull: false,
    comment: 'Setting key (e.g., "pricing_policy", "notification_email")'
  },
  value: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Setting value (string, number, or JSON)'
  },
  type: {
    type: DataTypes.ENUM('string', 'number', 'boolean', 'json', 'array'),
    defaultValue: 'string',
    comment: 'Data type of the setting value'
  },
  category: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'general',
    comment: 'Setting category (e.g., "pricing", "notifications", "general")'
  },
  description: {
    type: DataTypes.TEXT,
    comment: 'Description of the setting'
  },
  is_public: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    comment: 'Whether the setting is accessible via public API'
  },
  updated_at: {
    type: DataTypes.BIGINT,
    allowNull: false,
    comment: 'Timestamp of last update'
  }
}, {
  tableName: 'settings',
  timestamps: false,
  indexes: [
    { fields: ['key'], unique: true },
    { fields: ['category'] },
    { fields: ['is_public'] }
  ]
})

// Helper method to get typed value
Setting.prototype.getTypedValue = function() {
  const rawValue = this.value;

  switch (this.type) {
    case 'number':
      return Number(rawValue);
    case 'boolean':
      return rawValue === 'true' || rawValue === '1' || rawValue === 'yes';
    case 'json':
    case 'array':
      try {
        return JSON.parse(rawValue);
      } catch (e) {
        return rawValue;
      }
    case 'string':
    default:
      return rawValue;
  }
};

// ============================================
// Manual Product Fields (dynamic fields for manual products)
// ============================================
const ManualProductField = sequelize.define('ManualProductField', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  product_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Reference to manual_products.id'
  },
  field_name: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Name of the custom field (e.g., "Packaging", "RoHS Status")'
  },
  field_value: {
    type: DataTypes.TEXT,
    comment: 'Value of the custom field'
  },
  field_type: {
    type: DataTypes.ENUM('string', 'number', 'boolean', 'json'),
    defaultValue: 'string',
    comment: 'Data type of the field value'
  }
}, {
  tableName: 'manual_product_fields',
  indexes: [
    { fields: ['product_id'] },
    { fields: ['field_name'] },
    { fields: ['product_id', 'field_name'], unique: true }
  ]
})

// Define associations
ManualProduct.hasMany(ManualProductField, {
  foreignKey: 'product_id',
  as: 'customFields',
  onDelete: 'CASCADE'
})
ManualProductField.belongsTo(ManualProduct, {
  foreignKey: 'product_id',
  as: 'product'
})

// ============================================
// Export all models
// ============================================
export {
  sequelize,
  AdminUser,
  Order,
  ApiHealth,
  ApiKey,
  StaticPage,
  ManualProduct,
  ManualProductField,
  ProjectStat,
  AdminNotification,
  Setting
}
